import type {
    Video,
    PlaylistItemsResponse,
    VideosResponse,
    CommentsResponse,
    Reply, RepliesResponse, CommentEntity, ReplyEntity,
    Channel, ChannelsResponse, YTListResponse,
} from "./related-interfaces";
import {deleteRequest, fetchJSON, insertJSON, RequestString} from "./network-utils";
import { collectVideo, filterVideos } from "./helper-scripts";
import fixytm from "./cache-init";
import { getRelevantGapiKey } from "./cache-scripts";
import { type Comment } from "./related-interfaces";

// Network function for user country recognition; is required for content filtering features (DEPRECATED starting from v1.0.8
// as one of solutions for security concerns)
/* export async function fetchUserCountry () {
    const req: RequestString = new RequestString("https://ipinfo.io/json");
    req.appendArg(`token=${fixytm.apiKeys.IPINFO_API_KEY}`);
    const response = await fetchJSON(req);
    const object: IpinfoResponse = JSON.parse(response) as IpinfoResponse;
    return object.country;
} */

// Network function for fetching a playlist by its ID
export async function fetchPlaylist (id: string, [key, isOauthAccessToken] = getRelevantGapiKey()) {
    const output: string[] = [];
    let cycle = 0;
    const args: string[] = [
        "part=contentDetails",
        `playlistId=${id}`,
        `maxResults=${fixytm.MAX_PLAYLIST_PAGE_ITEMS}`,
        `${isOauthAccessToken ? "access_token" : "key"}=${key}`
    ]
    const pageTokenIndex = args.length;
    let undone = true;
    while (undone && cycle < fixytm.MAX_CYCLES_PER_FETCH_PLAYLIST) {
        const req: RequestString = new RequestString(`https://www.googleapis.com/youtube/v3/playlistItems?${args.join("&")}`);
        let response: string;
        try { response = await fetchJSON(req) } catch (e) {console.error(`FIX.YTM React error: fetchPlaylist: ${e}`); return []}
        const obj = JSON.parse(response) as PlaylistItemsResponse;
        for (const item of obj.items) output.push(item.contentDetails.videoId)
        if (obj.nextPageToken) { cycle++; args[pageTokenIndex] = `pageToken=${obj.nextPageToken}` } else undone = false;
    }

    return output;
}

// Network function for fetching a collection of videos by their IDs
export async function fetchVideos (
    ids: string[], filter: boolean = true,
    cacheVideos: boolean = true,
    checkAutoGenerated: boolean = true,
    [key, isOauthAccessToken] = getRelevantGapiKey()) {
    let output: Video[] = [];
    let cycle: number = 0;
    const max = fixytm.MAX_VIDEOS_PAGE_ITEMS;
    // noinspection SpellCheckingInspection
    const args: string[] = [
        "part=snippet%2Cstatistics%2CcontentDetails",
        `maxResults=${fixytm.MAX_VIDEOS_PAGE_ITEMS}`,
        `${isOauthAccessToken ? "access_token" : "key"}=${key}`
    ]
    let undone = true;
    while (undone && cycle < fixytm.MAX_CYCLES_PER_FETCH_VIDEO) {
        const idsPortion: string[] = [];
        for (let i = 0; i < max; i++) if(ids[i + max * cycle]) idsPortion.push(ids[i + max * cycle]);
        const req: RequestString = new RequestString(`https://www.googleapis.com/youtube/v3/videos?${args.join("&")}&id=${idsPortion.join("%2C")}`);
        let response: string;
        try { response = await fetchJSON(req) } catch (e) {console.error(`FIX.YTM React error: fetchVideos: ${e}`); return []}
        const obj = JSON.parse(response) as VideosResponse;
        for (const video of obj.items) output.push(video);
        if (output.length < ids.length) cycle++; else undone = false;
    }
    if (filter) output = filterVideos(output);
    if (checkAutoGenerated) output.forEach(video => { video.autoGenerated = /Auto-generated by YouTube/.test(video.snippet.description) })
    if (cacheVideos) fixytm.cache.videos.push(...output.filter((video) => !fixytm.cache.videos.find((cachedVideo) => video.id === cachedVideo.id)));
    return output;
}

// Network function for fetching a collection of channels by their IDs, or the user's channel
export async function fetchChannels (
    ids: string[], mine: boolean = true,
    cacheChannels: boolean = true,
    [key, isOauthAccessToken] = getRelevantGapiKey()
): Promise<Channel[] | Channel> {
    const output: Channel[] = [];
    let cycle = 0;
    const max = fixytm.MAX_CHANNELS_PAGE_ITEMS;
    const mineFactor = mine && isOauthAccessToken
    const args: string[] = [
        "part=snippet%2Cstatistics%2Cstatus",
        `maxResults=${mineFactor ? 1 : max}`,
        `mine=${mineFactor}`,
        `${isOauthAccessToken ? "access_token" : "key"}=${key}`
    ]
    let undone = true;
    while (undone && cycle < fixytm.MAX_CYCLES_PER_FETCH_CHANNELS) {
        const idsPortion: string[] = [];
        for (let i = 0; i < max; i++) if (ids[i + max * cycle]) idsPortion.push(ids[i + max * cycle]);
        const req = new RequestString(`https://www.googleapis.com/youtube/v3/channels?${args.join("&")}`);
        let response: string;
        try { response = await fetchJSON(req) } catch (e) {console.error(`FIX.YTM React error: fetchChannels: ${e}`); return []}
        const obj = JSON.parse(response) as ChannelsResponse;
        for (const channel of obj.items) output.push(channel);
        if (output.length < ids.length) cycle++; else undone = false;
    }
    if (cacheChannels) fixytm.cache.channels.push(...output.filter((channel) => !fixytm.cache.videos.find((cachedChannel) => channel.id === cachedChannel.id)));
    return mineFactor ? output[0] : output;
}

// Network function for fetching an array of comments by video ID
export async function fetchComments(
    videoId: string,
    cacheComments: boolean,
    nextPageToken?: string,
    [key, isOauthAccessToken] = getRelevantGapiKey()) {
    const output: Comment[] = [];
    let cycle = 0;
    const video = await collectVideo(videoId);
    const args: string[] = [
        "part=snippet",
        `maxResults=${fixytm.MAX_COMMENTS_PAGE_ITEMS}`,
        "order=relevance",
        `videoId=${videoId}`,
        `${isOauthAccessToken ? "access_token" : "key"}=${key}`,
    ]
    const pageTokenIndex = args.length;
    args[pageTokenIndex] = nextPageToken ? `${`pageToken=${nextPageToken}`}` : ""
    let undone = true;
    while (undone && cycle < fixytm.MAX_CYCLES_PER_FETCH_COMMENTS) {
        const req = new RequestString(`https://www.googleapis.com/youtube/v3/commentThreads?${args.join("&")}`);
        let response: string;
        try { response = await fetchJSON(req) } catch (e) { console.error(e); video.commentsOpen="closed"; return new Error(`FIX.YTM React error: The comment thread for this video is unavailable for an unknown reason. Read console for more info`) }
        const obj = JSON.parse(response) as CommentsResponse;
        for (const comment of obj.items) output.push(comment)
        if (obj.nextPageToken) { cycle++; args[pageTokenIndex] = `pageToken=${obj.nextPageToken}`; video.commentNextPageToken = obj.nextPageToken; }
        else { undone = false; video.commentNextPageToken = undefined; }

    }
    if (cacheComments) {
        video.comments = video.comments ? [...video.comments, ...output] : video.comments = [...output];
        video.commentsOpen = "open";
    }
    return output;
}

// Network function for fetching comment replies by comment ID
export async function fetchReplies(
    thread: Comment,
    [key, isOauthAccessToken] = getRelevantGapiKey()) {
    const output: Reply[] = [];
    let cycle = 0;
    const args: string[] = [
        "part=snippet",
        `maxResults=${fixytm.MAX_COMMENTS_PAGE_ITEMS}`,
        `parentId=${thread.id}`,
        `${isOauthAccessToken ? "access_token" : "key"}=${key}`
    ]
    const pageTokenIndex = args.length;
    let undone = true;
    while (undone && cycle < fixytm.MAX_CYCLES_PER_FETCH_COMMENTS) {
        const req = new RequestString(`https://www.googleapis.com/youtube/v3/comments?${args.join("&")}`);
        let response: string;
        try { response = await fetchJSON(req) } catch (e) { console.error(e); return new Error(`FIX.YTM React error: This comment thread is unavailable for an unknown reason. Read console for more info`) }
        const obj = JSON.parse(response) as RepliesResponse;
        for (const reply of obj.items) output.push(reply);
        if (obj.nextPageToken) { cycle++; args[pageTokenIndex] = `pageToken=${obj.nextPageToken}` } else undone = false;
    }
    thread.replies = { comments: output }

    return output;
}

// Network function for posting comment threads under videos
export async function insertCommentThread(
    video: Video,
    textOriginal: string,
    cacheThread: boolean = true,
    [key, isOauthAccessToken] = getRelevantGapiKey()) {
    const entry = JSON.stringify({
        snippet: {
            channelId: video.snippet.channelId,
            videoId: video.id,
            topLevelComment: {
                snippet: {
                    textOriginal: textOriginal,
                }
            }
        }
    } as CommentEntity) as string
    const postReq = new RequestString(
        `https://www.googleapis.com/youtube/v3/commentThreads?part=snippet&${isOauthAccessToken ? "access_token" : "key"}=${key}`);
    let response: string;
    try { response = await insertJSON(postReq, entry) as string; } catch (e) { console.error(e); return new Error(`FIX.YTM React error: Couldn't post this comment. Read console for more info`) }
    const obj = JSON.parse(response) as Comment;
    if (cacheThread) {
        if (video.comments) {
            video.comments.unshift(obj)
        } else { video.comments = [obj] }
    }
    return obj;
}

// Network function for posting comment replies under comments
export async function insertReply(
    thread: Comment,
    textOriginal: string,
    cacheReply: boolean = true,
    [key, isOauthAccessToken] = getRelevantGapiKey()) {
    const entry = JSON.stringify({
        snippet: {
            textOriginal: textOriginal,
            parentId: thread.id
        }
    } as ReplyEntity) as string
    const postReq = new RequestString(
        `https://www.googleapis.com/youtube/v3/comments?part=snippet&${isOauthAccessToken ? "access_token" : "key"}=${key}`)
    let response: string;
    try { response = await insertJSON(postReq, entry) as string; } catch (e) { console.error(e); return new Error(`FIX.YTM React error: Couldn't post this comment. Read console for more info`) }
    const obj = JSON.parse(response) as Reply;
    if (cacheReply) {
        if (thread.replies) {
            thread.replies.comments.unshift(obj)
        } else {
            thread.replies = {
                comments: [obj]
            }
        }
    }
}

// Network function for deleting a comment thread by its ID
export async function deleteCommentThread(
    comment: Comment,
    [key, isOauthAccessToken] = getRelevantGapiKey()) {
    const args = [
        `id=${comment.id}`,
        `${isOauthAccessToken ? "access_token" : "key"}=${key}`,
    ]
    const deleteReq = new RequestString(`https://www.googleapis.com/youtube/v3/comments?${args.join("&")}`);
    let result: boolean;
    try { result = await deleteRequest(deleteReq) } catch (e) { console.error(`FIX.YTM React error: deleteCommentThread: ${e}`); return false }
    if (result) {
        comment.snippet.topLevelComment.snippet.textDisplay = "You have deleted this comment"
        comment.replies = undefined
    }
    return result
}

// Network function for deleting a reply by its ID
export async function deleteReply(
    reply: Reply,
    [key, isOauthAccessToken] = getRelevantGapiKey()) {
    const args = [
        `id=${reply.id}`,
        `${isOauthAccessToken ? "access_token" : "key"}=${key}`,
    ]
    const deleteReq = new RequestString(`https://www.googleapis.com/youtube/v3/comments?${args.join("&")}`);
    let result: boolean;
    try { result = await deleteRequest(deleteReq) } catch (e) { console.error(`FIX.YTM React error: deleteReply: ${e}`); return false }
    if (result) {
        reply.snippet.textDisplay = "You have deleted this reply"
    }
    return result
}

type SearchType = "channel" | "playlist" | "video"
type SearchOrder = "date" | "rating" | "relevance" | "title" | "videoCount" | "viewCount"

// Network function for retrieving a search result or a list of search results by query
export async function search({
    type = "video",
    maxResults = 1,
    order = "relevance",
    channelId,
    query
}: {type: SearchType, maxResults?: number, order?: SearchOrder, channelId?: string, query: string}, [key, isOauthAccessToken] = getRelevantGapiKey()): Promise<unknown | unknown[]> {
    const args = [
        `part=snippet`,
        `type=${type}`,
        `maxResults=${maxResults}`,
        `order=${order}`,
        channelId ? `channelId=${channelId}` : null,
        `q=${encodeURIComponent(query)}`,
        `${isOauthAccessToken ? "access_token" : "key"}=${key}`,
    ]
    const req = new RequestString(`https://www.googleapis.com/youtube/v3/search?${args.join("&")}`);
    let response;
    try { response = await fetchJSON(req) } catch (e) { console.error(`FIX.YTM React error: search: ${e}`); return [] }
    const list = JSON.parse(response) as YTListResponse;
    return maxResults === 1 ? list.items[0] : list.items;
}